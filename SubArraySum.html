<!DOCTYPE html>
<html>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<!---styling the header with css-->
	<style>
	.header{
	  padding: 40px;
	  text-align: center;
	  background: #9785a8;
	  color: white;
	}

	.header h1{
	  font-size: 40px;
	}

	.navbar{
	  overflow: hidden;
	  background-color: #ffffff;
	}

	.navbar a{
	  float:left;
	  display: block;
	  color: black;
	  text-align: center;
	  padding: 15px 15px;
	  text-decoration: none;
	}
	.navbar a:hover{
	  padding: 15px;
	  background-color: #d4bff5;
	  color: white;
	}

	.SimHeader {
	  font-size:25px;
	  text-align: center;
	  border-color: black;
	  border-bottom-style: solid;
	  border-width: 1px;
	  font-family: Arial;
	}

	.defs {
	  border-style: dashed;
	  border-color: black;
	  border-width: 1px;
	  font-family: Arial;
	  padding: 10px 20px;
	}

	.duck {
		margin:15px;
		margin-top:0px;
		display:inline-block;
		width:50px;
		height:50px;
	}

	#spacing{
		height:200px;
	}

	p {
		/*This is a hack, please find a solution...*/
		margin-top: -46px;
		margin-left: 35px;
	}

	#duckWrapper {
		margin:auto;
		text-align: center;
		width:100%;
		position:relative;
	}

	#UIWrapper {
		margin:auto;
		margin-top:0px;
		text-align: center;
		width:100%;

	}

	#hose {
		width:50px;
		height:80px;
		/*display:inline-block;
		width:0px;
		height:0px;

		border-left: 30px solid transparent;
		border-right: 30px solid transparent;
		border-bottom: 80px solid red;*/

	}

	#hoseWrapper {
		margin:auto;
		margin-top:180px;
		text-align: center;
		width:100%;
	}

	#backgroundWrapper{
		margin:auto;
		margin-top:10px;
		text-align: center;
		background-size:cover;
		width:975px;
		height:650px;
		object-fit: center;
		background-repeat: no-repeat;

	}

	#Explanation {
		display: none;
		margin: 15px;
		text-align: center;
	}

	#ExplanationWrapper {
		margin: 50px;
	}

	.explanationButtons {
		margin: auto;
		text-align: center;
		display:block;
	}

	#Instruction{
		display: block;
		margin: 15px;
		text-align:center;
	}
	#InstructionWrapper{
		margin: 50px;

	}

	.instructionButtons{
		margin: auto;
		text-align: center;
		display:block;
	}

	#sprayButton{
		width:125px;
		height: 100px;
		margin-top: 20px;
		margin-left: 700px;
		background-image: url('spraysign.png');
		background-repeat: no-repeat;
		background-position: 50% 50%;
		height: 73px;
		width:115px;
		border: none;
	}

	#sprayPicture{
		width:115px;

	}


	</style>
	<div class="header">
	  <h1>Welcome to the MHC Algorithms Help Website!</h1>

	</div>

	<div class="navbar">
	  <a href = "index.html">Home</a>
	  <a href = "StableMatchIntro.html">Stable Matching Simulation</a>
	  <a href = "SubArraySum.html">Duck Game (Divide-and-Conquer)</a>
	</div>


	<body>
		<div id ="instructionWrapper">
			<button id="hideInstruction" class="instructionButtons" type="button" onclick="
				$('#Instruction').css('display', 'none');
				
				$('#hideInstruction').css('display', 'none');
				$('#showInstruction').css('display', 'block');
			">Hide Instructions and Rules</button>
			<button id="showInstruction" class="instructionButtons" style="display:none" type="button" onclick="$('#Instruction').css('display', 'block');
				
				$('#hideInstruction').css('display', 'block');
				$('#showInstruction').css('display', 'none');
				">Show Instructions and Rules
			</button>
			
			<p id="Instruction">
				In this game, your goal is to get the highest score possible! You have to choose a set of ducks that are in a row to spray with the hose. <br>

				There are 3 levels, then a free play mode where you can pick the number of ducks (with a max of 16).
				<br>
				<br>
				
				You choose the ducks by clicking on the duck at the start and at the end of the selection you want to make.
				<br>

				You may deselect a duck at the start or end of your selection by clicking on those ducks.
				<br><br>

				If you think you have chosen the best set of ducks, click the button that says "Spray"
			</p>

		</div>

		<div id ="backgroundWrapper" style="background-image: url('background1.png');">
			<div id ="spacing"></div>
			<div id="duckWrapper"></div>
			<div id="hoseWrapper">
				<img id="hose" src ="./hose.png"></img>

			</div>
			<button id="sprayButton" type="button" onclick="hose()"><!-- <img id="sprayPicture"src='spraysign.png'></img> --><!-- Confirm Selection --></button>
			<div id="UIWrapper">
			<button type="button" onclick="repopulate()">New Game</button>
			<input type=text value=2 id="nInput">
			</div>
		</div>

		<!-- <div id="UIWrapper">
			<button type="button" onclick="repopulate()">New Game</button>
			<input type=text value=2 id="nInput">
			<button type="button" onclick="hose()">Confirm Selection</button>
		</div> -->

		<div id="ExplanationWrapper">
			<button id="showExplanation" class="explanationButtons" type="button" onclick="
				$('#Explanation').css('display', 'block');
				
				$('#hideExplanation').css('display', 'block');
				$('#showExplanation').css('display', 'none');
			">Show Algorithm Explanation</button>
			<button id="hideExplanation" class="explanationButtons" style="display:none" type="button" onclick="
				$('#Explanation').css('display', 'none');
				
				$('#hideExplanation').css('display', 'none');
				$('#showExplanation').css('display', 'block');
			">Hide Algorithm Explanation</button>
			<p id="Explanation">
				<a href="https://youtu.be/ohHWQf1HDfU?t=431">If a YouTube video would be easier, we found this one to be helpful.</a><br><br>

				<br>

				In this example we will refer to this example array: <b>arr = [-2, 1, -3, 8]</b><br><br>

				Let's break arr down into equal halves and pretend that we already know the Maximum Subarray Sum of each of them:<br>
				<b>sub_one = [-2, 1], sum_one = 1           sub_two = [-3, 8], sum_two = 8</b><br>
				We'll explain how we know sum_one and sum_two in a minute.<br><br>

				The Maximum Subarray for <b>arr</b> is either <b>sub_one</b>, <b>sub_two</b>, some overlap between <b>sub_one</b> and <b>sub_two</b> called <b>sub_overlap</b>.<br>
				So first we must calculate <b>sub_overlap</b>, then we can chose the largest of the three sums.<br><br>

				To calculate <b>sub_overlap</b> we will get a start index from <b>sub_one</b> and an end index from <b>sub_two</b>.<br>
				To do this, we build a maximal <b>sub_sub_one</b> from right to left:<br>
				<b>
					the first sub_sub_one is empty<br>
					sub_sub_one = []<br><br>

					now, we try the second sub_sub_one array with a length of 1:<br>
					new_sub_sub_one = [1]<br>
					the sum of new_sub_sub_one > the sum of sub_sub_one, so sub_sub_one = new_sub_sub_one<br><br>

					now, we try the third sub_sub_one array with a length of 2:<br>
					new_sub_sub_one = [1, -2]<br>
					the sum of new_sub_sub_one < the sum of sub_sub_one, so sub_sub_one stays the same<br><br>

					we have reached the end of sub_one with sub_sub_one = [1]<br><br>
				</b>
				So now we know that the start index of <b>sub_overlap</b> = 1.<br><br>
				To find the end index of <b>sub_overlap</b>, we build a maximal <b>sub_sub_two</b> from left to right:<br>
				<b>
					the first sub_sub_two is empty<br>
					sub_sub_two = []<br><br>

					now, we try the second sub_sub_two array with a length of 1:<br>
					new_sub_sub_two = [-3]<br>
					the sum of new_sub_sub_two > the sum of sub_sub_two, so sub_sub_two = new_sub_sub_two<br><br>

					now, we try the third sub_sub_two array with a length of 2:<br>
					new_sub_sub_two = [-3, 8]<br>
					the sum of new_sub_sub_two > the sum of sub_sub_two, so sub_sub_two = new_sub_sub_two<br><br>

					we have reached the end of sub_two with sub_sub_two = [5]<br><br>
				</b>
				So now we know that the end index of <b>sub_overlap</b> = 3, and we can calculate <b>sum_overlap</b> to be sum(arr[1] through arr[3]) = <b>6</b>.<br><br>

				Finally we can compare <b>sum_one</b>, <b>sum_two</b>, and <b>sum_overlap</b> to find that <b>sum_two</b> is the greatest, so the Maximum Subarray Sum of <b>arr</b> is <b>arr[3] through arr[3] = 8</b>.<br><br><br><br>



				This proceedure is the recursive step we'll be using. We break the given array down into smaller and smaller subarrays until we reach a base case.<br>
				Using our <b>arr</b> example:<br>
				[-2, 1, -3, 8] =><br>
				[-2, 1] and [-3, 8]<br>
				[-2, 1] =><br>
				-2 and 1<br>
				Here we would compare <b>sub_one</b>: -2, <b>sub_two</b>: 1, and <b>sub_overlap</b>: -1<br>
				We would choose <b>sub_two</b>, since it is larger.<br>
				This is how we got <b>sub_one</b>, <b>sum_one</b>, <b>sub_two</b>, and <b>sum_two</b> in the above description of the recursive step!<br><br><br>


				This algorithm works very cleanly for arrays with a number of elements equal to some power of two. The process is the same for less convenient numbers, but the math isn't as beautiful.<br><br><br>


				Feel free to experiment with different values of n! Once you get to level 8 (where the number of ducks = n = 8), you are free to type in any number between 1 and 16 inclusive and try out your algorithmic understanding.
			</p>
		</div>
		<script>
			var level = 0;

			var n = 2;
			var maxN = 16;

			var duckDOMs = [];
			var duckValues = [];
			var startDuck = -1;
			var endDuck = -1;

			var playerSum = null;

			repopulate();

			//setInterval(checkLevel, 500); 
        	//setInterval(checkN, 500); //Every 500 millis checks to see if n has changed

        	//set levels
        	function checkLevel(){
	        	if(level==0){
	        		n=2;
	        		document.getElementById("nInput").value = n;
	        		repopulate();
	        	}
	        	else if(level==1){
	        		n=4;
	        		document.getElementById("nInput").value = n;
	        		repopulate();
	        	}
	        	else if(level==2){
	        		n=8;
	        		document.getElementById("nInput").value = n;
	        		repopulate();
	        	}
	        	else{
	        		repopulate();
	        		setInterval(checkN, 500); 
	        		if(n<=12){
		      			document.getElementById("hoseWrapper").style.marginTop = "180px";
		     		}
		     		else if(n>12){
		      			document.getElementById("hoseWrapper").style.marginTop = "115px";
		    		}

	        		//allow to make own numbers
	        	}
        	}

        	//Checks if n has changed
		    function checkN(){
		   
		      var newN = document.getElementById("nInput").value;
		      if(newN != n && newN > 0 && newN <= maxN){
		        n = newN;	
		        checkLevel();	        
		        repopulate();
		       }
		    }
		    

		    //Restarts the game
		    function repopulate(){
				//Clear #duckWrapper
				for(var i = 0; i < duckDOMs.length; i++){
	        		document.getElementById("duckWrapper").removeChild(duckDOMs[i]);
	        	}

	        	duckDOMs = [];
	        	duckValues = [];
	        	startDuck = -1;
	        	endDuck = -1;

	        	playerSum = null;

	        	duckValues = generateArray(n);

	        	for(var i = 0; i < n; i++){
	        		var duck = makeDuck(duckValues[i], i);
	        		duckDOMs[i] = duck;
	        		duckWrapper.appendChild(duck);
	        	}
		    }

		    //Updates the GUI and selected subarray of ducks
		    function updateDuckSelection(){
		    	var runningSum = 0;
		    	for(var i = 0; i < n; i++){
		    		var text = duckDOMs[i].children[1];

		    		if(startDuck <= i && i <= endDuck){
		    			text.style = "color:red";
		    			var val = parseInt(text.innerHTML);
		    			runningSum += val;
		    		}else{
		    			text.style = "color:black";
		    		}
		    	}
		    	
		    	playerSum = runningSum;
		    }

		    //Returns a duck GUI element with a value of val and id of duck + i
		    function makeDuck(val, i){
		    	var duck = document.createElement("div");
		    	duck.id = "duck" + i;
		    	duck.className = "duck";

		    	//var duckImg = document.createElement("div");		//Div for now, will be img when we have img of duck
		    	var duckImg = document.createElement("IMG");
		    	duckImg.setAttribute("src", "./duck.png");

		    	duckImg.className = "duckPart";
		    	duckImg.style = "width:80px;height:80px;";

		    	var duckNum = document.createElement("p");
		    	duckNum.className = "duckPart";
		    	duckNum.innerHTML = val;

		    	duck.appendChild(duckImg);
		    	duck.appendChild(duckNum);

		    	return duck;
		    }

		    //Play the hose animation and check to see if player was right
		    function hose(){
		    	if(startDuck == -1){
		    		alert("Please make a selection");
		    	}else{
			    	var correctSum = maxSubarraySum(duckValues);

			    	if(correctSum == playerSum){
			    		alert("Winner! Your value of " + playerSum + " was the best you could get!");
			    		level++;
			    		checkLevel();
			    	}else{
			    		alert("Sorry :( Your sum was " + playerSum + ", but you could have gotten " + correctSum);
			    	}
			    }
		    }

			//creates an array of size n of values between -10 and 10
			function generateArray(n){
				var points = [];
				var min = -4; 
				var max = 10;
				var negativeCount = 0;

				for(var i=0; i<n; i++){
					var rand = Math.floor(Math.random()*(+max - +min))+ +min;
					
					//this prevents all the numbers from being negative
					if(rand<0){
						negativeCount++;
					}
					if(negativeCount==n){
						rand = rand*-1;
					}
					points.push(rand);
				}

				return points;
			}

			function maxSubarraySum(array){
				var max_end = 0;
				var max_count = 0;

				for(var i = 0; i<array.length; i++){
					max_end += array[i];

					if(max_count < max_end){
						max_count = max_end;
					}

					if(max_end < 0){
						max_end = 0;
					}
				}
				//if it's all negative numbers it defaults to zero... added preventative measure to genArray
				return max_count;
			}

			$(document).ready(function(){
			    //Handle Duck Being Clicked
			    $("body").on("click", ".duck", function(){
			    	var duck = $(this)[0];
			    	var duckId = duck.id;
			    	var duckNum = parseInt(duckId.substring(4));

			    	if(startDuck == -1 && endDuck == -1){		//First Click of the Game
			    		startDuck = duckNum;
			    		endDuck = duckNum;
			    	}else{								//There already exists a start and end duck
			    		if(duckNum == startDuck && startDuck == endDuck){
			    			startDuck = -1;
			    			endDuck = -1;
			    		}else if(duckNum == startDuck){
			    			startDuck++;
			    		}else if(duckNum == endDuck){
			    			endDuck--;
			    		}else if(duckNum > endDuck){	//This should be the new end duck
			    			endDuck = duckNum;
			    		}else if(duckNum < startDuck){	//This should be the new start duck
			    			startDuck = duckNum;
			    		}else{							//This should be the new start or end duck, whichever is closest
			    			var distToStart = duckNum - startDuck;
			    			var distToEnd = endDuck - duckNum;

			    			if(distToEnd < distToStart){
			    				endDuck = duckNum;
			    			}else{
			    				startDuck = duckNum;
			    			}
			    		}
			    	}

			    	updateDuckSelection();
			    });
			});
		</script>	
	</body>
</html>
